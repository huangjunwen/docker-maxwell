package main

import (
	"encoding/json"
	"fmt"
	"log"
	"regexp"
	"strconv"
	"strings"
	"sync/atomic"
	"time"

	"github.com/go-redis/redis"
	"github.com/tidwall/redcon"
)

var (
	listenAddr   = ":6378"
	upstreamAddr = ":6379"
	maxLenApprox = int64(0) // 0 for unlimited
)

var (
	posRegexp = regexp.MustCompile(`^[^\.]+\.(\d+):(\d+)`)
)

// ParseBinlogPos is used to parse binlog position generated by maxwell: `mysql-bin.000001:4563719`
//
// The maximum `fileNum` is roughly `1<<31` which is defined as `MAX_LOG_UNIQUE_FN_EXT` in `sql/sql.h`, ref:
//   - https://dba.stackexchange.com/questions/94286/what-will-happen-to-the-binary-log-if-it-reaches-its-maximum-value-does-it-res
//   - http://adamcscott.blogspot.com/2014/06/mysql-55-maximum-sequence-in-binary-logs.html
//
// The maximum `filePos` should be no more than the maximum `----max-binlog-size` (`1<<30`).
//
// So in fact uint32 should be enough for both of them.
func ParseBinlogPos(pos interface{}) (ok bool, fileNum, filePos uint64) {
	s, ok := pos.(string)
	if !ok {
		return
	}

	parts := posRegexp.FindStringSubmatch(s)
	if parts == nil {
		return false, 0, 0
	}

	fileNum, err := strconv.ParseUint(parts[1], 10, 32)
	if err != nil {
		return false, 0, 0
	}

	filePos, err = strconv.ParseUint(parts[2], 10, 32)
	if err != nil {
		return false, 0, 0
	}

	return true, fileNum, filePos
}

// FormatStreamId uses binlog postion and a counter to generate a redis stream id.
func FormatStreamId(fileNum, filePos, counter uint64) string {
	return fmt.Sprintf("%d-%d", (fileNum<<32)+filePos, counter)
}

// ParseStreamId is the reverse operation of FormatStreamId.
func ParseStreamId(id string) (ok bool, fileNum, filePos, counter uint64) {
	parts := strings.Split(id, "-")
	if len(parts) != 2 {
		return false, 0, 0, 0
	}

	part, err := strconv.ParseUint(parts[0], 10, 64)
	if err != nil {
		return false, 0, 0, 0
	}
	fileNum = part >> 32
	filePos = part & ((1 << 32) - 1)

	counter, err = strconv.ParseUint(parts[1], 10, 64)
	if err != nil {
		return false, 0, 0, 0
	}

	return true, fileNum, filePos, counter
}

type Handler struct {
	// upstream is the real redis server.
	upstream *redis.Client

	// runningHandlers is the number of running handlers. Must be less or equal to 1:
	// messages must be sent one by one.
	runningHandlers int32

	// prevPosition remembers the binlog postion of last message.
	prevPosition string

	// counterOfPosition is the counter of messages within a same binlog postion.
	// NOTE: maxwell may emit several messages in one binlog postion
	counterOfPosition uint64

	// messages is the json message.
	message maxwellMessage
}

type maxwellMessage struct {
	Position string `json:"position"`
}

func (h *Handler) Run(conn redcon.Conn, cmd redcon.Command) {
	// Ensure only one running handler.
	if atomic.AddInt32(&h.runningHandlers, 1) > 1 {
		panic(fmt.Errorf("Messages must be sent one by one"))
	}
	defer atomic.AddInt32(&h.runningHandlers, -1)

	// Cleanup.
	defer func() {
		h.prevPosition = h.message.Position
		h.message = maxwellMessage{}
	}()

	// Expect xadd only.
	cmdName := strings.ToLower(string(cmd.Args[0]))
	if cmdName != "xadd" {
		panic(fmt.Errorf("Got unexpected command %q", cmdName))
	}

	// Extract args.
	key := string(cmd.Args[1]) // 'maxwell'
	// id := cmd.Args[2] // '*'
	field := string(cmd.Args[3]) // 'message'
	value := cmd.Args[4]         // json encoded
	if err := json.Unmarshal(value, &h.message); err != nil {
		panic(fmt.Errorf("Decode json error: %s", err.Error()))
	}

	// NOTE: Ignore it silently if the message has no position.
	position := h.message.Position
	if position == "" {
		// Returns an invalid id.
		// XXX: the minimal valid id is '0-1'. See https://redis.io/commands/xadd
		conn.WriteString("0-0")
		return
	}

	// Parse the binlog position.
	ok, fileNum, filePos := ParseBinlogPos(position)
	if !ok {
		panic(fmt.Errorf("Parse binlog position failed: %+q", position))
	}

	// Reset & incr counter.
	if position != h.prevPosition {
		h.counterOfPosition = 0
	}
	h.counterOfPosition++

	// Format stream id.
	id := FormatStreamId(fileNum, filePos, h.counterOfPosition)
	// log.Printf("[DEB] Cur is %s %s\n", id, value)

	// Now send to upstream.
	result, err := h.upstream.XAdd(&redis.XAddArgs{
		Stream:       key,
		MaxLenApprox: maxLenApprox,
		ID:           id,
		Values: map[string]interface{}{
			field: value,
		},
	}).Result()
	if err != nil {
		panic(fmt.Errorf("Xadd error: %s", err.Error()))
	}
	conn.WriteString(result)
}

func main() {

	upstream := redis.NewClient(&redis.Options{
		Addr: upstreamAddr,
	})

	// Wait upstream ready.
	for {
		_, err := upstream.Ping().Result()
		if err == nil {
			break
		}
		log.Printf("[ERR] Ping returns error: %s, wait a while...\n", err)
		time.Sleep(time.Second)
	}

	handler := &Handler{
		upstream: upstream,
	}

	err := redcon.ListenAndServe(
		listenAddr,
		handler.Run,
		func(conn redcon.Conn) bool {
			log.Printf("[INF] Accept conn[%s]\n", conn.RemoteAddr())
			return true
		},
		func(conn redcon.Conn, err error) {
			log.Printf("[INF] Conn closed[%s]: %s\n", conn.RemoteAddr(), err)
		},
	)
	if err != nil {
		log.Printf("[ERR] ListenAndServe returns err: %s", err)
	}
}
